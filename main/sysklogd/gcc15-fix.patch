--- a/syslogd.c
+++ b/syslogd.c
@@ -811,12 +811,12 @@
 void printsys(char *msg);
 void logmsg(int pri, char *msg, const char *from, int flags);
 void fprintlog(register struct filed *f, char *from, int flags, char *msg);
-void endtty();
+void endtty(int);
 void wallmsg(register struct filed *f, struct iovec *iov);
-void reapchild();
+void reapchild(int);
 const char *cvthname(struct sockaddr_in *f);
-void domark();
-void debug_switch();
+void domark(int);
+void debug_switch(int);
 void logerror(char *type);
 void die(int sig);
 #ifndef TESTING
@@ -828,7 +828,7 @@
 #define dprintf mydprintf
 static void dprintf(char *, ...);
 static void allocate_log(void);
-void sighup_handler();
+void sighup_handler(int);
 
 #ifdef SYSLOG_UNIXAF
 static int create_unix_socket(const char *path);
@@ -2016,7 +2016,7 @@
 
 jmp_buf ttybuf;
 
-void endtty()
+void endtty(int)
 {
 	longjmp(ttybuf, 1);
 }
@@ -2124,7 +2124,7 @@
 	reenter = 0;
 }
 
-void reapchild()
+void reapchild(int)
 {
 	int saved_errno = errno;
 #if defined(SYSV) && !defined(linux)
@@ -2205,7 +2205,7 @@
 	return (hp->h_name);
 }
 
-void domark()
+void domark(int)
 {
 	register struct filed *f;
 #ifdef SYSV
@@ -2239,7 +2239,7 @@
 	(void) alarm(TIMERINTVL);
 }
 
-void debug_switch()
+void debug_switch(int)
 
 {
 	dprintf("Switching debugging_on to %s\n", (debugging_on == 0) ? "true" : "false");
@@ -2938,7 +2938,7 @@
  * doing this during a signal handler.  Instead this function simply sets
  * a flag variable which will tell the main loop to go through a restart.
  */
-void sighup_handler()
+void sighup_handler(int)
 
 {
 	restart = 1;
--- a/syslog.c
+++ b/syslog.c
@@ -139,7 +139,7 @@
 	/* substitute error message for %m */
 	{
 		register char ch, *t1, *t2;
-		char *strerror();
+		char *strerror(int);
 
 		for (t1 = fmt_cpy;
 		     (ch = *fmt) != '\0' && t1<fmt_cpy+sizeof(fmt_cpy);
