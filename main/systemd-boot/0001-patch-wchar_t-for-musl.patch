From 01ce16f1299237946cf07f54952b72e533e5c59b Mon Sep 17 00:00:00 2001
From: Struan Robertson <contact@struan.tech>
Date: Thu, 18 Sep 2025 15:32:35 +0100
Subject: [PATCH] patch wchar_t for musl

---
 src/basic/stdio-util.h      |  2 +-
 src/boot/efi-string.c       | 10 +++++-----
 src/boot/efi.h              |  6 +++---
 src/boot/fuzz-efi-printf.c  |  2 +-
 src/boot/test-efi-string.c  |  2 +-
 src/test/test-format-util.c |  4 ++--
 6 files changed, 13 insertions(+), 13 deletions(-)

diff --git a/src/basic/stdio-util.h b/src/basic/stdio-util.h
index 052087ce15..f9412e8be2 100644
--- a/src/basic/stdio-util.h
+++ b/src/basic/stdio-util.h
@@ -49,7 +49,7 @@ do {                                                                    \
                         (void) va_arg(ap, long long int);               \
                         break;                                          \
                 case PA_WCHAR:                                          \
-                        (void) va_arg(ap, wchar_t);                     \
+                        (void) va_arg(ap, uint16_t);                     \
                         break;                                          \
                 case PA_WSTRING:                                        \
                 case PA_STRING:                                         \
diff --git a/src/boot/efi-string.c b/src/boot/efi-string.c
index 8e2c73d84d..08003fac5a 100644
--- a/src/boot/efi-string.c
+++ b/src/boot/efi-string.c
@@ -597,7 +597,7 @@ typedef struct {
         bool have_field_width;
 
         const char *str;
-        const wchar_t *wstr;
+        const uint16_t *wstr;
 
         /* For numbers. */
         bool is_signed;
@@ -658,7 +658,7 @@ static bool push_str(FormatContext *ctx, SpecifierContext *sp) {
                 push_padding(ctx, ' ', sp->padded_len);
 
         /* In userspace unit tests we cannot just memcpy() the wide string. */
-        if (sp->wstr && sizeof(wchar_t) == sizeof(char16_t)) {
+        if (sp->wstr && sizeof(uint16_t) == sizeof(char16_t)) {
                 memcpy(ctx->buf + ctx->n, sp->wstr, sp->len * sizeof(*sp->wstr));
                 ctx->n += sp->len;
         } else {
@@ -752,7 +752,7 @@ static bool handle_format_specifier(FormatContext *ctx, SpecifierContext *sp) {
          * int in vararg functions, which is why we fetch only ints for any such types. The compiler would
          * otherwise warn about fetching smaller types. */
         assert_cc(sizeof(int) == 4);
-        assert_cc(sizeof(wchar_t) <= sizeof(int));
+        assert_cc(sizeof(uint16_t) <= sizeof(int));
         assert_cc(sizeof(long long) == sizeof(intmax_t));
 
         assert(ctx);
@@ -847,13 +847,13 @@ static bool handle_format_specifier(FormatContext *ctx, SpecifierContext *sp) {
                 return push_str(ctx, sp);
 
         case 'c':
-                sp->wstr = &(wchar_t){ va_arg(ctx->ap, int) };
+                sp->wstr = &(uint16_t){ va_arg(ctx->ap, int) };
                 sp->len = 1;
                 return push_str(ctx, sp);
 
         case 's':
                 if (sp->long_arg) {
-                        sp->wstr = va_arg(ctx->ap, const wchar_t *) ?: L"(null)";
+                        sp->wstr = va_arg(ctx->ap, const uint16_t *) ?: L"(null)";
                         sp->len = wcsnlen(sp->wstr, sp->len);
                 } else {
                         sp->str = va_arg(ctx->ap, const char *) ?: "(null)";
diff --git a/src/boot/efi.h b/src/boot/efi.h
index 1832df980c..4e6a2f7288 100644
--- a/src/boot/efi.h
+++ b/src/boot/efi.h
@@ -16,7 +16,7 @@
 
 #if SD_BOOT
 /* uchar.h/wchar.h are not suitable for freestanding environments. */
-typedef __WCHAR_TYPE__ wchar_t;
+typedef __WCHAR_TYPE__ uint16_t;
 typedef __CHAR16_TYPE__ char16_t;
 typedef __CHAR32_TYPE__ char32_t;
 
@@ -28,7 +28,7 @@ assert_cc(sizeof(uint8_t) == 1);
 assert_cc(sizeof(uint16_t) == 2);
 assert_cc(sizeof(uint32_t) == 4);
 assert_cc(sizeof(uint64_t) == 8);
-assert_cc(sizeof(wchar_t) == 2);
+assert_cc(sizeof(uint16_t) == 2);
 assert_cc(sizeof(char16_t) == 2);
 assert_cc(sizeof(char32_t) == 4);
 assert_cc(sizeof(size_t) == sizeof(void *));
@@ -38,7 +38,7 @@ assert_cc(alignof(uint8_t) == 1);
 assert_cc(alignof(uint16_t) == 2);
 assert_cc(alignof(uint32_t) == 4);
 assert_cc(alignof(uint64_t) == 8);
-assert_cc(alignof(wchar_t) == 2);
+assert_cc(alignof(uint16_t) == 2);
 assert_cc(alignof(char16_t) == 2);
 assert_cc(alignof(char32_t) == 4);
 
diff --git a/src/boot/fuzz-efi-printf.c b/src/boot/fuzz-efi-printf.c
index 2857b389a2..ec2a45568f 100644
--- a/src/boot/fuzz-efi-printf.c
+++ b/src/boot/fuzz-efi-printf.c
@@ -44,7 +44,7 @@ int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
         fuzz_setup_logging();
 
         PRINTF_ONE(i->status, "%*.*s", i->field_width, (int) len, i->str);
-        PRINTF_ONE(i->status, "%*.*ls", i->field_width, (int) (len / sizeof(wchar_t)), (const wchar_t *) i->str);
+        PRINTF_ONE(i->status, "%*.*ls", i->field_width, (int) (len / sizeof(uint16_t)), (const uint16_t *) i->str);
 
         PRINTF_ONE(i->status, "%% %*.*m", i->field_width, i->precision);
         PRINTF_ONE(i->status, "%*p", i->field_width, i->ptr);
diff --git a/src/boot/test-efi-string.c b/src/boot/test-efi-string.c
index e0d3bd9b71..52c65d753d 100644
--- a/src/boot/test-efi-string.c
+++ b/src/boot/test-efi-string.c
@@ -705,7 +705,7 @@ TEST(xvasprintf_status) {
         test_printf_one("%-14ls %-10.0ls %-10.3ls", L"left", L"", L"chopped");
 
         test_printf_one("%.6s", (char[]){ 'n', 'o', ' ', 'n', 'u', 'l' });
-        test_printf_one("%.6ls", (wchar_t[]){ 'n', 'o', ' ', 'n', 'u', 'l' });
+        test_printf_one("%.6ls", (uint16_t[]){ 'n', 'o', ' ', 'n', 'u', 'l' });
 
         test_printf_one("%u %u %u", 0U, 42U, 1234567890U);
         test_printf_one("%i %i %i", 0, -42, -1234567890);
diff --git a/src/test/test-format-util.c b/src/test/test-format-util.c
index 0a95837dbe..d07333a5d1 100644
--- a/src/test/test-format-util.c
+++ b/src/test/test-format-util.c
@@ -18,8 +18,8 @@ assert_cc(STRLEN(U"") == 0);
 assert_cc(STRLEN(U"a") == sizeof(char32_t));
 assert_cc(STRLEN(U"123") == 3 * sizeof(char32_t));
 assert_cc(STRLEN(L"") == 0);
-assert_cc(STRLEN(L"a") == sizeof(wchar_t));
-assert_cc(STRLEN(L"123") == 3 * sizeof(wchar_t));
+assert_cc(STRLEN(L"a") == sizeof(uint16_t));
+assert_cc(STRLEN(L"123") == 3 * sizeof(uint16_t));
 assert_cc(DECIMAL_STR_MAX(uint8_t) == STRLEN("255")+1);
 assert_cc(DECIMAL_STR_MAX(int8_t) == STRLEN("-127")+1);
 assert_cc(DECIMAL_STR_MAX(uint64_t) == STRLEN("18446744073709551615")+1);
-- 
2.51.0

