--- a/Source/MediaStorageAndFileFormat/gdcmFileStreamer.cxx
+++ b/Source/MediaStorageAndFileFormat/gdcmFileStreamer.cxx
@@ -33,10 +33,10 @@

 #if defined(_WIN32) && (defined(_MSC_VER) || defined(__MINGW32__))
 #include <io.h>
-typedef int64_t off64_t;
+typedef int64_t off_t;
 #else
 #if defined(__APPLE__) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__) || defined(__EMSCRIPTEN__)
-#  define off64_t off_t
+#  define off_t off_t
 #endif
 #include <unistd.h> // ftruncate
 #endif
@@ -50,9 +50,9 @@
 // handling of 64bits offset. Create thin wrapper:
 // See here for discussion:
 // http://stackoverflow.com/questions/17863594/size-of-off-t-at-compilation-time
-// Basically enforce use of off64_t over off_t since on windows off_t is pretty
+// Basically enforce use of off_t over off_t since on windows off_t is pretty
 // much guarantee to be 32bits only.
-static inline int FSeeko(FILE *stream, off64_t offset, int whence)
+static inline int FSeeko(FILE *stream, off_t offset, int whence)
 {
 #ifdef _WIN32
 #if defined(__MINGW32__)
@@ -65,7 +65,7 @@
 #endif
 }

-static inline off64_t FTello(FILE *stream)
+static inline off_t FTello(FILE *stream)
 {
 #ifdef _WIN32
 #if defined(__MINGW32__)
@@ -78,7 +78,7 @@
 #endif
 }

-static inline bool FTruncate( const int fd, const off64_t len )
+static inline bool FTruncate( const int fd, const off_t len )
 {
 #ifdef _WIN32
 #if defined(__MINGW32__)
@@ -96,7 +96,7 @@
 #endif
 }

-static bool prepare_file( FILE * pFile, const off64_t offset, const off64_t inslen )
+static bool prepare_file( FILE * pFile, const off_t offset, const off_t inslen )
 {
   // fast path
   if( inslen == 0 ) return true;
@@ -111,13 +111,13 @@
     {
     if( inslen < 0 )
       {
-      off64_t bytes_to_move = sb.st_size - offset;
-      off64_t read_start_offset = offset;
+      off_t bytes_to_move = sb.st_size - offset;
+      off_t read_start_offset = offset;
       while (bytes_to_move != 0)
         {
-        const size_t bytes_this_time = static_cast<size_t>(std::min((off64_t)BUFFERSIZE, bytes_to_move));
-        const off64_t rd_off = read_start_offset;
-        const off64_t wr_off = rd_off + inslen;
+        const size_t bytes_this_time = static_cast<size_t>(std::min((off_t)BUFFERSIZE, bytes_to_move));
+        const off_t rd_off = read_start_offset;
+        const off_t wr_off = rd_off + inslen;
         if( FSeeko(pFile, rd_off, SEEK_SET) )
           {
           return false;
@@ -151,14 +151,14 @@
 #endif
       if (sb.st_size > offset)
         {
-        off64_t bytes_to_move = sb.st_size - offset;
-        off64_t read_end_offset = sb.st_size;
+        off_t bytes_to_move = sb.st_size - offset;
+        off_t read_end_offset = sb.st_size;
         while (bytes_to_move != 0)
           {
-          const size_t bytes_this_time = static_cast<size_t>(std::min((off64_t)BUFFERSIZE, bytes_to_move));
-          const off64_t rd_off = read_end_offset - bytes_this_time;
-          gdcm_assert( (off64_t)rd_off >= offset );
-          const off64_t wr_off = rd_off + inslen;
+          const size_t bytes_this_time = static_cast<size_t>(std::min((off_t)BUFFERSIZE, bytes_to_move));
+          const off_t rd_off = read_end_offset - bytes_this_time;
+          gdcm_assert( (off_t)rd_off >= offset );
+          const off_t wr_off = rd_off + inslen;
           if( FSeeko(pFile, rd_off, SEEK_SET) )
             {
             return false;
@@ -329,15 +329,15 @@
       size_t dicomlen = 4 + 4; // Tag + VL for Implicit
       if( TS.GetNegociatedType() == TransferSyntax::Explicit )
         dicomlen += 4;
-      off64_t newlen = len;
+      off_t newlen = len;
       gdcm_assert( (size_t)newlen == len );
       newlen += dicomlen;
       newlen -= actualde;
-      off64_t plength = newlen;
+      off_t plength = newlen;
       gdcm_assert( ReservedDataLength >= 0 );
       if( ReservedDataLength )
         {
-        if( (newlen + ReservedDataLength) >= (off64_t)len )
+        if( (newlen + ReservedDataLength) >= (off_t)len )
           {
           plength = newlen + ReservedDataLength - len;
           }
@@ -348,8 +348,8 @@
         ReservedDataLength -= len;
         gdcm_assert( ReservedDataLength >= 0 );
         }
-      //if( !prepare_file( pFile, (off64_t)thepos + actualde, newlen ) )
-      if( !prepare_file( pFile, (off64_t)thepos + actualde, plength ) )
+      //if( !prepare_file( pFile, (off_t)thepos + actualde, newlen ) )
+      if( !prepare_file( pFile, (off_t)thepos + actualde, plength ) )
         {
         return false;
         }
@@ -363,18 +363,18 @@
     else
       {
       gdcm_assert( pFile );
-      const off64_t curpos = FTello(pFile);
+      const off_t curpos = FTello(pFile);
       gdcm_assert( curpos == thepos );
-      if( ReservedDataLength >= (off64_t)len )
+      if( ReservedDataLength >= (off_t)len )
         {
         // simply update remaining reserved buffer:
         ReservedDataLength -= len;
         }
       else
         {
-        const off64_t plength = len - ReservedDataLength;
+        const off_t plength = len - ReservedDataLength;
         gdcm_assert( plength >= 0 );
-        if( !prepare_file( pFile, (off64_t)curpos, plength) )
+        if( !prepare_file( pFile, (off_t)curpos, plength) )
           {
           return false;
           }
@@ -395,14 +395,14 @@
     // Update DataElement:
     const size_t currentdatalenth = CurrentDataLenth;
     gdcm_assert( ReservedDataLength >= 0);
-    //const off64_t refpos = FTello(pFile);
+    //const off_t refpos = FTello(pFile);
     if( !UpdateDataElement( t ) )
       {
       return false;
       }
     if( ReservedDataLength > 0)
       {
-      const off64_t curpos = thepos;
+      const off_t curpos = thepos;
       if( !prepare_file( pFile, curpos + ReservedDataLength, - ReservedDataLength) )
         {
         return false;
@@ -587,7 +587,7 @@
     pFile = fopen(outfilename, "r+b");
     gdcm_assert( pFile );

-    if( !prepare_file( pFile, (off64_t)thepcpos, pclen ) )
+    if( !prepare_file( pFile, (off_t)thepcpos, pclen ) )
       {
       return false;
       }
@@ -673,7 +673,7 @@
   size_t actualde;
   size_t CurrentDataLenth;
   Tag CurrentGroupTag;
-  off64_t ReservedDataLength{0};
+  off_t ReservedDataLength{0};
   unsigned short ReservedGroupDataElement{0};
 public:
   FileStreamer *Self{nullptr};
@@ -685,7 +685,7 @@
       {
       if( CurrentDataLenth % 2 == 1 )
         {
-        const off64_t curpos = FTello(pFile);
+        const off_t curpos = FTello(pFile);
         if( ReservedDataLength >= 1 )
           {
           // simply update remaining reserved buffer:
@@ -693,7 +693,7 @@
           }
         else
           {
-          if( !prepare_file( pFile, (off64_t)curpos, 1) )
+          if( !prepare_file( pFile, (off_t)curpos, 1) )
             {
             return false;
             }
@@ -705,7 +705,7 @@
         CurrentDataLenth += 1;
         }
       gdcm_assert( CurrentDataLenth % 2 == 0 );
-      off64_t vlpos = thepos;
+      off_t vlpos = thepos;
       vlpos -= CurrentDataLenth;
       vlpos -= 4; // VL
       if( TS.GetNegociatedType() == TransferSyntax::Explicit )
@@ -723,7 +723,7 @@
       }
     return true;
     }
-  size_t WriteHelper( off64_t offset, const Tag & tag, const VL & vl )
+  size_t WriteHelper( off_t offset, const Tag & tag, const VL & vl )
     {
     FSeeko(pFile, offset, SEEK_SET);
     std::stringstream ss;
@@ -768,7 +768,7 @@
   static int checksize = 0;
   if( !checksize )
     {
-    const int soff = sizeof( off64_t );
+    const int soff = sizeof( off_t );
     const int si64 = sizeof( int64_t );
     if( soff != si64 ) return false;
     if( !(sizeof(sb.st_size) > 4) ) // LFS ?
