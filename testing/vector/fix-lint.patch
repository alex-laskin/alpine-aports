diff --git a/lib/file-source-common/src/buffer.rs b/lib/file-source-common/src/buffer.rs
index 76af2ccd2..e2a4e5596 100644
--- a/lib/file-source-common/src/buffer.rs
+++ b/lib/file-source-common/src/buffer.rs
@@ -206,7 +206,7 @@ mod test {
                     // was outside the max_size range _or_ the current chunk is empty.
                     let has_valid_delimiter = facts
                         .iter()
-                        .any(|details| ((details.chunk_index == idx) && details.within_max_size));
+                        .any(|details| (details.chunk_index == idx) && details.within_max_size);
                     assert!(chunk.is_empty() || !has_valid_delimiter)
                 }
                 ReadResult {
diff --git a/lib/file-source/src/file_server.rs b/lib/file-source/src/file_server.rs
index b9e6778b2..8aab4c7c4 100644
--- a/lib/file-source/src/file_server.rs
+++ b/lib/file-source/src/file_server.rs
@@ -261,7 +261,7 @@ where
 
                 let remove_file_tasks: HashMap<Id, PathBuf> = known_small_files
                     .iter()
-                    .filter(|&(_path, last_time_open)| (last_time_open.elapsed() >= grace_period))
+                    .filter(|&(_path, last_time_open)| last_time_open.elapsed() >= grace_period)
                     .map(|(path, _last_time_open)| path.clone())
                     .map(|path| {
                         let path_ = path.clone();
diff --git a/src/sinks/new_relic/healthcheck.rs b/src/sinks/new_relic/healthcheck.rs
index dd5a4bb79..96e1820bd 100644
--- a/src/sinks/new_relic/healthcheck.rs
+++ b/src/sinks/new_relic/healthcheck.rs
@@ -7,12 +7,14 @@ use super::NewRelicCredentials;
 use crate::{http::HttpClient, sinks::HealthcheckError};
 
 #[derive(Serialize, Deserialize, Debug)]
+#[allow(dead_code)]
 struct NewRelicStatusModel {
     page: NewRelicStatusPage,
     components: Vec<NewRelicStatusComponent>,
 }
 
 #[derive(Serialize, Deserialize, Debug)]
+#[allow(dead_code)]
 struct NewRelicStatusPage {
     id: String,
     name: String,
@@ -20,6 +22,7 @@ struct NewRelicStatusPage {
 }
 
 #[derive(Serialize, Deserialize, Debug)]
+#[allow(dead_code)]
 struct NewRelicStatusComponent {
     id: String,
     name: String,
diff --git a/src/sources/util/encoding_config.rs b/src/sources/util/encoding_config.rs
index e24a24201..4903c3ed1 100644
--- a/src/sources/util/encoding_config.rs
+++ b/src/sources/util/encoding_config.rs
@@ -4,6 +4,7 @@ use vector_lib::configurable::configurable_component;
 #[configurable_component]
 #[derive(Clone, Debug, PartialEq, Eq)]
 #[serde(deny_unknown_fields)]
+#[allow(dead_code)]
 pub struct EncodingConfig {
     /// Encoding of the source messages.
     ///
diff --git a/vdev/src/app.rs b/vdev/src/app.rs
index 49e595b58..d49f7d5bf 100644
--- a/vdev/src/app.rs
+++ b/vdev/src/app.rs
@@ -27,7 +27,7 @@ const DEFAULT_SHELL: &str = "/bin/sh";
 // Extract the shell from the environment variable `$SHELL` and substitute the above default value
 // if it isn't set.
 pub static SHELL: LazyLock<OsString> =
-    LazyLock::new(|| (env::var_os("SHELL").unwrap_or_else(|| DEFAULT_SHELL.into())));
+    LazyLock::new(|| env::var_os("SHELL").unwrap_or_else(|| DEFAULT_SHELL.into()));
 
 static VERBOSITY: OnceLock<LevelFilter> = OnceLock::new();
 static CONFIG: OnceLock<Config> = OnceLock::new();
