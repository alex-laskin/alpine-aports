Patch-Source: https://github.com/MayaPosch/NymphCast/commit/e972ff11894e383c65bde3fd14a7726e590b68f2,
              https://github.com/MayaPosch/NymphCast/commit/e5178e993b36c4843640801320eeeea1434bbfd0
---
From e972ff11894e383c65bde3fd14a7726e590b68f2 Mon Sep 17 00:00:00 2001
From: Maya Posch <1096451+MayaPosch@users.noreply.github.com>
Date: Tue, 10 Sep 2024 22:35:19 +0200
Subject: [PATCH] Patch player for new FFmpeg audio channel API.

---
 src/server/ffplay/audio_renderer.cpp | 150 ++++++++++++++++++++++-----
 src/server/ffplay/audio_renderer.h   |   3 +-
 src/server/ffplay/decoder.cpp        |   3 +-
 src/server/ffplay/decoder.h          |   2 +-
 src/server/ffplay/sdl_renderer.cpp   |   3 +-
 src/server/ffplay/stream_handler.cpp |  35 ++++---
 src/server/ffplay/types.h            |   5 +-
 src/server/ffplay/video_renderer.cpp |  13 ++-
 8 files changed, 168 insertions(+), 46 deletions(-)

diff --git a/src/server/ffplay/audio_renderer.cpp b/src/server/ffplay/audio_renderer.cpp
index 418b103a..f8f53d0b 100644
--- a/src/server/ffplay/audio_renderer.cpp
+++ b/src/server/ffplay/audio_renderer.cpp
@@ -11,14 +11,14 @@
 std::atomic<bool> AudioRenderer::run;
 
 
-static inline
+/* static inline
 int64_t get_valid_channel_layout(int64_t channel_layout, int channels)
 {
     if (channel_layout && av_get_channel_layout_nb_channels(channel_layout) == channels)
         return channel_layout;
     else
         return 0;
-}
+} */
 
 static inline
 int cmp_audio_fmts(enum AVSampleFormat fmt1, int64_t channel_count1,
@@ -120,6 +120,9 @@ static int configure_filtergraph(AVFilterGraph *graph, const char *filtergraph,
 }
 
 
+#include "libavutil/bprint.h"
+
+
 int AudioRenderer::configure_audio_filters(VideoState *is, const char *afilters, int force_output_format) {
     static const enum AVSampleFormat sample_fmts[] = { AV_SAMPLE_FMT_S16, AV_SAMPLE_FMT_NONE };
     int sample_rates[2] = { 0, -1 };
@@ -128,6 +131,7 @@ int AudioRenderer::configure_audio_filters(VideoState *is, const char *afilters,
     AVFilterContext *filt_asrc = NULL, *filt_asink = NULL;
     char aresample_swr_opts[512] = "";
     AVDictionaryEntry *e = NULL;
+    AVBPrint bp;
     char asrc_args[256];
     int ret;
 
@@ -142,14 +146,22 @@ int AudioRenderer::configure_audio_filters(VideoState *is, const char *afilters,
         aresample_swr_opts[strlen(aresample_swr_opts)-1] = '\0';
     av_opt_set(is->agraph, "aresample_swr_opts", aresample_swr_opts, 0);
 
-    ret = snprintf(asrc_args, sizeof(asrc_args),
+    /* ret = snprintf(asrc_args, sizeof(asrc_args),
                    "sample_rate=%d:sample_fmt=%s:channels=%d:time_base=%d/%d",
                    is->audio_filter_src.freq, av_get_sample_fmt_name(is->audio_filter_src.fmt),
                    is->audio_filter_src.channels,
-                   1, is->audio_filter_src.freq);
-    if (is->audio_filter_src.channel_layout)
+                   1, is->audio_filter_src.freq); */
+				   
+	av_channel_layout_describe_bprint(&is->audio_filter_src.ch_layout, &bp);
+
+    ret = snprintf(asrc_args, sizeof(asrc_args),
+                   "sample_rate=%d:sample_fmt=%s:time_base=%d/%d:channel_layout=%s",
+                   is->audio_filter_src.freq, av_get_sample_fmt_name(is->audio_filter_src.fmt),
+                   1, is->audio_filter_src.freq, bp.str);
+	
+    /* if (is->audio_filter_src.channel_layout)
         snprintf(asrc_args + ret, sizeof(asrc_args) - ret,
-                 ":channel_layout=0x%" PRIx64,  is->audio_filter_src.channel_layout);
+                 ":channel_layout=0x%" PRIx64,  is->audio_filter_src.channel_layout); */
 
     ret = avfilter_graph_create_filter(&filt_asrc,
                                        avfilter_get_by_name("abuffer"), "ffplay_abuffer",
@@ -169,7 +181,7 @@ int AudioRenderer::configure_audio_filters(VideoState *is, const char *afilters,
     if ((ret = av_opt_set_int(filt_asink, "all_channel_counts", 1, AV_OPT_SEARCH_CHILDREN)) < 0)
         goto end;
 
-    if (force_output_format) {
+    /* if (force_output_format) {
         channel_layouts[0] = is->audio_tgt.channel_layout;
         channels       [0] = is->audio_tgt.channels;
         sample_rates   [0] = is->audio_tgt.freq;
@@ -181,6 +193,16 @@ int AudioRenderer::configure_audio_filters(VideoState *is, const char *afilters,
             goto end;
         if ((ret = av_opt_set_int_list(filt_asink, "sample_rates"   , sample_rates   ,  -1, AV_OPT_SEARCH_CHILDREN)) < 0)
             goto end;
+    } */
+	
+	if (force_output_format) {
+        sample_rates   [0] = is->audio_tgt.freq;
+        if ((ret = av_opt_set_int(filt_asink, "all_channel_counts", 0, AV_OPT_SEARCH_CHILDREN)) < 0)
+            goto end;
+        if ((ret = av_opt_set(filt_asink, "ch_layouts", bp.str, AV_OPT_SEARCH_CHILDREN)) < 0)
+            goto end;
+        if ((ret = av_opt_set_int_list(filt_asink, "sample_rates"   , sample_rates   ,  -1, AV_OPT_SEARCH_CHILDREN)) < 0)
+            goto end;
     }
 
 
@@ -229,11 +251,11 @@ static int audio_decode_frame(VideoState *is)
         FrameQueueC::frame_queue_next(&is->sampq);
     } while (af->serial != is->audioq.serial);
 
-    data_size = av_samples_get_buffer_size(NULL, af->frame->channels,
+    data_size = av_samples_get_buffer_size(NULL, af->frame->ch_layout.nb_channels,
                                            af->frame->nb_samples,
                                            (AVSampleFormat) af->frame->format, 1);
 
-    dec_channel_layout =
+    /* dec_channel_layout =
         (af->frame->channel_layout && af->frame->channels == av_get_channel_layout_nb_channels(af->frame->channel_layout)) ?
         af->frame->channel_layout : av_get_default_channel_layout(af->frame->channels);
     wanted_nb_samples = synchronize_audio(is, af->frame->nb_samples);
@@ -259,13 +281,39 @@ static int audio_decode_frame(VideoState *is)
         is->audio_src.channels       = af->frame->channels;
         is->audio_src.freq = af->frame->sample_rate;
         is->audio_src.fmt = (AVSampleFormat) af->frame->format;
+    } */
+	
+	wanted_nb_samples = synchronize_audio(is, af->frame->nb_samples);
+
+    if (af->frame->format        != is->audio_src.fmt            ||
+        av_channel_layout_compare(&af->frame->ch_layout, &is->audio_src.ch_layout) ||
+        af->frame->sample_rate   != is->audio_src.freq           ||
+        (wanted_nb_samples       != af->frame->nb_samples && !is->swr_ctx)) {
+        swr_free(&is->swr_ctx);
+        swr_alloc_set_opts2(&is->swr_ctx,
+                            &is->audio_tgt.ch_layout, is->audio_tgt.fmt, is->audio_tgt.freq,
+                            &af->frame->ch_layout, (AVSampleFormat) af->frame->format, af->frame->sample_rate,
+                            0, NULL);
+        if (!is->swr_ctx || swr_init(is->swr_ctx) < 0) {
+            av_log(NULL, AV_LOG_ERROR,
+                   "Cannot create sample rate converter for conversion of %d Hz %s %d channels to %d Hz %s %d channels!\n",
+                    af->frame->sample_rate, av_get_sample_fmt_name((AVSampleFormat) af->frame->format), af->frame->ch_layout.nb_channels,
+                    is->audio_tgt.freq, av_get_sample_fmt_name(is->audio_tgt.fmt), is->audio_tgt.ch_layout.nb_channels);
+            swr_free(&is->swr_ctx);
+            return -1;
+        }
+        if (av_channel_layout_copy(&is->audio_src.ch_layout, &af->frame->ch_layout) < 0)
+            return -1;
+        is->audio_src.freq = af->frame->sample_rate;
+        is->audio_src.fmt = (AVSampleFormat) af->frame->format;
     }
 
     if (is->swr_ctx) {
         const uint8_t **in = (const uint8_t **)af->frame->extended_data;
         uint8_t **out = &is->audio_buf1;
         int out_count = (int64_t)wanted_nb_samples * is->audio_tgt.freq / af->frame->sample_rate + 256;
-        int out_size  = av_samples_get_buffer_size(NULL, is->audio_tgt.channels, out_count, is->audio_tgt.fmt, 0);
+        //int out_size  = av_samples_get_buffer_size(NULL, is->audio_tgt.channels, out_count, is->audio_tgt.fmt, 0);
+		int out_size  = av_samples_get_buffer_size(NULL, is->audio_tgt.ch_layout.nb_channels, out_count, is->audio_tgt.fmt, 0);
         int len2;
         if (out_size < 0) {
             av_log(NULL, AV_LOG_ERROR, "av_samples_get_buffer_size() failed\n");
@@ -292,7 +340,8 @@ static int audio_decode_frame(VideoState *is)
                 swr_free(&is->swr_ctx);
         }
         is->audio_buf = is->audio_buf1;
-        resampled_data_size = len2 * is->audio_tgt.channels * av_get_bytes_per_sample(is->audio_tgt.fmt);
+        //resampled_data_size = len2 * is->audio_tgt.channels * av_get_bytes_per_sample(is->audio_tgt.fmt);
+		resampled_data_size = len2 * is->audio_tgt.ch_layout.nb_channels * av_get_bytes_per_sample(is->audio_tgt.fmt);
     } else {
         is->audio_buf = af->frame->data[0];
         resampled_data_size = data_size;
@@ -382,24 +431,35 @@ static void sdl_audio_callback(void *opaque, Uint8 *stream, int len)
     }
 }
 
-int AudioRenderer::audio_open(void *opaque, int64_t wanted_channel_layout, int wanted_nb_channels, int wanted_sample_rate, struct AudioParams *audio_hw_params)
+//int AudioRenderer::audio_open(void *opaque, int64_t wanted_channel_layout, int wanted_nb_channels, int wanted_sample_rate, struct AudioParams *audio_hw_params)
+int AudioRenderer::audio_open(void *opaque, AVChannelLayout* wanted_channel_layout, int wanted_sample_rate, struct AudioParams *audio_hw_params)
 {
     SDL_AudioSpec wanted_spec, spec;
     const char *env;
     static const int next_nb_channels[] = {0, 0, 1, 6, 2, 6, 4, 6};
     static const int next_sample_rates[] = {0, 44100, 48000, 96000, 192000};
     int next_sample_rate_idx = FF_ARRAY_ELEMS(next_sample_rates) - 1;
+    int wanted_nb_channels = wanted_channel_layout->nb_channels;
 
     env = SDL_getenv("SDL_AUDIO_CHANNELS");
     if (env) {
         wanted_nb_channels = atoi(env);
-        wanted_channel_layout = av_get_default_channel_layout(wanted_nb_channels);
+        //wanted_channel_layout = av_get_default_channel_layout(wanted_nb_channels);
+        av_channel_layout_uninit((AVChannelLayout*) wanted_channel_layout);
+        av_channel_layout_default((AVChannelLayout*) wanted_channel_layout, wanted_nb_channels);
     }
-    if (!wanted_channel_layout || wanted_nb_channels != av_get_channel_layout_nb_channels(wanted_channel_layout)) {
+    /* if (!wanted_channel_layout || wanted_nb_channels != av_get_channel_layout_nb_channels(wanted_channel_layout)) {
         wanted_channel_layout = av_get_default_channel_layout(wanted_nb_channels);
         wanted_channel_layout &= ~AV_CH_LAYOUT_STEREO_DOWNMIX;
+    } */
+	
+	if (wanted_channel_layout->order != AV_CHANNEL_ORDER_NATIVE) {
+        av_channel_layout_uninit((AVChannelLayout*) wanted_channel_layout);
+        av_channel_layout_default((AVChannelLayout*) wanted_channel_layout, wanted_nb_channels);
     }
-    wanted_nb_channels = av_get_channel_layout_nb_channels(wanted_channel_layout);
+	
+    //wanted_nb_channels = av_get_channel_layout_nb_channels(wanted_channel_layout);
+	wanted_nb_channels = wanted_channel_layout->nb_channels;
     wanted_spec.channels = wanted_nb_channels;
     wanted_spec.freq = wanted_sample_rate;
     if (wanted_spec.freq <= 0 || wanted_spec.channels <= 0) {
@@ -426,16 +486,22 @@ int AudioRenderer::audio_open(void *opaque, int64_t wanted_channel_layout, int w
                 return -1;
             }
         }
-        wanted_channel_layout = av_get_default_channel_layout(wanted_spec.channels);
+        
+		//wanted_channel_layout = av_get_default_channel_layout(wanted_spec.channels);
+		av_channel_layout_default(wanted_channel_layout, wanted_spec.channels);
     }
     if (spec.format != AUDIO_S16SYS) {
         av_log(NULL, AV_LOG_ERROR,
                "SDL advised audio format %d is not supported!\n", spec.format);
         return -1;
     }
+	
     if (spec.channels != wanted_spec.channels) {
-        wanted_channel_layout = av_get_default_channel_layout(spec.channels);
-        if (!wanted_channel_layout) {
+        //wanted_channel_layout = av_get_default_channel_layout(spec.channels);
+		av_channel_layout_uninit(wanted_channel_layout);
+		av_channel_layout_default(wanted_channel_layout, wanted_spec.channels);
+        //if (!wanted_channel_layout) {
+		if (wanted_channel_layout->order != AV_CHANNEL_ORDER_NATIVE) {
             av_log(NULL, AV_LOG_ERROR,
                    "SDL advised channel count %d is not supported!\n", spec.channels);
             return -1;
@@ -444,10 +510,15 @@ int AudioRenderer::audio_open(void *opaque, int64_t wanted_channel_layout, int w
 
     audio_hw_params->fmt = AV_SAMPLE_FMT_S16;
     audio_hw_params->freq = spec.freq;
-    audio_hw_params->channel_layout = wanted_channel_layout;
-    audio_hw_params->channels =  spec.channels;
-    audio_hw_params->frame_size = av_samples_get_buffer_size(NULL, audio_hw_params->channels, 1, audio_hw_params->fmt, 1);
-    audio_hw_params->bytes_per_sec = av_samples_get_buffer_size(NULL, audio_hw_params->channels, audio_hw_params->freq, audio_hw_params->fmt, 1);
+    //audio_hw_params->channel_layout = wanted_channel_layout;
+    //audio_hw_params->channels =  spec.channels;
+    //audio_hw_params->frame_size = av_samples_get_buffer_size(NULL, audio_hw_params->channels, 1, audio_hw_params->fmt, 1);
+    //audio_hw_params->bytes_per_sec = av_samples_get_buffer_size(NULL, audio_hw_params->channels, audio_hw_params->freq, audio_hw_params->fmt, 1);
+	if (av_channel_layout_copy(&audio_hw_params->ch_layout, wanted_channel_layout) < 0)
+        return -1;
+	
+    audio_hw_params->frame_size = av_samples_get_buffer_size(NULL, audio_hw_params->ch_layout.nb_channels, 1, audio_hw_params->fmt, 1);
+    audio_hw_params->bytes_per_sec = av_samples_get_buffer_size(NULL, audio_hw_params->ch_layout.nb_channels, audio_hw_params->freq, audio_hw_params->fmt, 1);
     if (audio_hw_params->bytes_per_sec <= 0 || audio_hw_params->frame_size <= 0) {
         av_log(NULL, AV_LOG_ERROR, "av_samples_get_buffer_size failed\n");
         return -1;
@@ -468,7 +539,7 @@ int AudioRenderer::audio_thread(void *arg) {
     Frame *af;
 #if CONFIG_AVFILTER
     int last_serial = -1;
-    int64_t dec_channel_layout;
+    //int64_t dec_channel_layout;
     int reconfigure;
 #endif
     int got_frame = 0;
@@ -489,9 +560,9 @@ int AudioRenderer::audio_thread(void *arg) {
                 tb = AVRational{1, frame->sample_rate};
 
 #if CONFIG_AVFILTER
-                dec_channel_layout = get_valid_channel_layout(frame->channel_layout, frame->channels);
+                //dec_channel_layout = get_valid_channel_layout(frame->channel_layout, frame->channels);
 
-                reconfigure =
+                /* reconfigure =
                     cmp_audio_fmts(is->audio_filter_src.fmt, is->audio_filter_src.channels,
                                    (AVSampleFormat) frame->format, frame->channels)    ||
                     is->audio_filter_src.channel_layout != dec_channel_layout ||
@@ -515,7 +586,34 @@ int AudioRenderer::audio_thread(void *arg) {
 
                     if ((ret = configure_audio_filters(is, afilters, 1)) < 0)
                         goto the_end;
-                }
+                } */
+				
+				// 6.x start
+				reconfigure =
+                    cmp_audio_fmts(is->audio_filter_src.fmt, is->audio_filter_src.ch_layout.nb_channels, (AVSampleFormat) frame->format, frame->ch_layout.nb_channels)    ||
+                    av_channel_layout_compare(&is->audio_filter_src.ch_layout, &frame->ch_layout) ||
+                    is->audio_filter_src.freq           != frame->sample_rate ||
+                    is->auddec.pkt_serial               != last_serial;
+
+                if (reconfigure) {
+                    char buf1[1024], buf2[1024];
+                    av_channel_layout_describe(&is->audio_filter_src.ch_layout, buf1, sizeof(buf1));
+                    av_channel_layout_describe(&frame->ch_layout, buf2, sizeof(buf2));
+                    av_log(NULL, AV_LOG_DEBUG,
+                           "Audio frame changed from rate:%d ch:%d fmt:%s layout:%s serial:%d to rate:%d ch:%d fmt:%s layout:%s serial:%d\n",
+                           is->audio_filter_src.freq, is->audio_filter_src.ch_layout.nb_channels, av_get_sample_fmt_name(is->audio_filter_src.fmt), buf1, last_serial,
+                           frame->sample_rate, frame->ch_layout.nb_channels, av_get_sample_fmt_name((AVSampleFormat) frame->format), buf2, is->auddec.pkt_serial);
+
+                    is->audio_filter_src.fmt            = (AVSampleFormat) frame->format;
+                    ret = av_channel_layout_copy(&is->audio_filter_src.ch_layout, &frame->ch_layout);
+                    if (ret < 0)
+                        goto the_end;
+                    is->audio_filter_src.freq           = frame->sample_rate;
+                    last_serial                         = is->auddec.pkt_serial;
+
+                    if ((ret = configure_audio_filters(is, afilters, 1)) < 0)
+                        goto the_end;
+                } // 6.x end
 
             if ((ret = av_buffersrc_add_frame(is->in_audio_filter, frame)) < 0)
                 goto the_end;
diff --git a/src/server/ffplay/audio_renderer.h b/src/server/ffplay/audio_renderer.h
index 8dd7ea04..050fec93 100644
--- a/src/server/ffplay/audio_renderer.h
+++ b/src/server/ffplay/audio_renderer.h
@@ -14,7 +14,8 @@ class AudioRenderer {
 	static std::atomic<bool> run;
 	
 public:
-	static int audio_open(void *opaque, int64_t wanted_channel_layout, int wanted_nb_channels, int wanted_sample_rate, struct AudioParams *audio_hw_params);
+	//static int audio_open(void *opaque, int64_t wanted_channel_layout, int wanted_nb_channels, int wanted_sample_rate, struct AudioParams *audio_hw_params);
+	static int audio_open(void *opaque, AVChannelLayout* wanted_channel_layout, int wanted_sample_rate, struct AudioParams *audio_hw_params);
 	static int audio_thread(void *arg);
 	static int configure_audio_filters(VideoState *is, const char *afilters, int force_output_format);
 	
diff --git a/src/server/ffplay/decoder.cpp b/src/server/ffplay/decoder.cpp
index cd691b80..0d11fb24 100644
--- a/src/server/ffplay/decoder.cpp
+++ b/src/server/ffplay/decoder.cpp
@@ -7,13 +7,14 @@
 
 
 
-void DecoderC::decoder_init(Decoder *d, AVCodecContext *avctx, PacketQueue *queue, SDL_cond *empty_queue_cond) {
+int DecoderC::decoder_init(Decoder *d, AVCodecContext *avctx, PacketQueue *queue, SDL_cond *empty_queue_cond) {
     memset(d, 0, sizeof(Decoder));
     d->avctx = avctx;
     d->queue = queue;
     d->empty_queue_cond = empty_queue_cond;
     d->start_pts = AV_NOPTS_VALUE;
     d->pkt_serial = -1;
+	return 0;
 }
 
 int DecoderC::decoder_decode_frame(Decoder *d, AVFrame *frame, AVSubtitle *sub) {
diff --git a/src/server/ffplay/decoder.h b/src/server/ffplay/decoder.h
index 69ccfa9d..d2c220bd 100644
--- a/src/server/ffplay/decoder.h
+++ b/src/server/ffplay/decoder.h
@@ -11,7 +11,7 @@ class DecoderC {
 	//
 	
 public:
-	static void decoder_init(Decoder *d, AVCodecContext *avctx, PacketQueue *queue, SDL_cond *empty_queue_cond);
+	static int decoder_init(Decoder *d, AVCodecContext *avctx, PacketQueue *queue, SDL_cond *empty_queue_cond);
 	static int decoder_start(Decoder *d, int (*fn)(void *), const char *thread_name, void* arg);
 	static void decoder_abort(Decoder *d, FrameQueue *fq);
 	static void decoder_destroy(Decoder *d);
diff --git a/src/server/ffplay/sdl_renderer.cpp b/src/server/ffplay/sdl_renderer.cpp
index 27ca5643..36ef3cb3 100644
--- a/src/server/ffplay/sdl_renderer.cpp
+++ b/src/server/ffplay/sdl_renderer.cpp
@@ -657,7 +657,8 @@ void SdlRenderer::video_audio_display(VideoState *s) {
 	nb_freq = 1 << (rdft_bits - 1);
 
 	/* compute display index : center on currently output samples */
-	channels = s->audio_tgt.channels;
+	//channels = s->audio_tgt.channels;
+	channels = s->audio_tgt.ch_layout.nb_channels;
 	nb_display_channels = channels;
 	if (!s->paused) {
 		int data_used= s->show_mode == SHOW_MODE_WAVES ? s->width.load() : (2*nb_freq);
diff --git a/src/server/ffplay/stream_handler.cpp b/src/server/ffplay/stream_handler.cpp
index 113936ef..145accfe 100644
--- a/src/server/ffplay/stream_handler.cpp
+++ b/src/server/ffplay/stream_handler.cpp
@@ -173,14 +173,14 @@ int cmp_audio_fmts(enum AVSampleFormat fmt1, int64_t channel_count1,
         return channel_count1 != channel_count2 || fmt1 != fmt2;
 }
 
-static inline
+/* static inline
 int64_t get_valid_channel_layout(int64_t channel_layout, int channels)
 {
     if (channel_layout && av_get_channel_layout_nb_channels(channel_layout) == channels)
         return channel_layout;
     else
         return 0;
-}
+} */
 
 
 int StreamHandler::get_master_sync_type(VideoState *is) {
@@ -212,8 +212,9 @@ int StreamHandler::stream_component_open(VideoState *is, int stream_index) {
     const char *forced_codec_name = NULL;
     AVDictionary *opts = NULL;
     AVDictionaryEntry *t = 0;
-    int sample_rate, nb_channels;
-    int64_t channel_layout;
+    int sample_rate; //, nb_channels;
+    AVChannelLayout ch_layout = {};
+    //int64_t channel_layout;
     int ret = 0;
     int stream_lowres = lowres;
 
@@ -298,8 +299,11 @@ int StreamHandler::stream_component_open(VideoState *is, int stream_index) {
             AVFilterContext *sink;
 
             is->audio_filter_src.freq           = avctx->sample_rate;
-            is->audio_filter_src.channels       = avctx->channels;
-            is->audio_filter_src.channel_layout = get_valid_channel_layout(avctx->channel_layout, avctx->channels);
+            //is->audio_filter_src.channels       = avctx->channels;
+            //is->audio_filter_src.channel_layout = get_valid_channel_layout(avctx->channel_layout, avctx->channels);
+			ret = av_channel_layout_copy(&is->audio_filter_src.ch_layout, &avctx->ch_layout);
+            if (ret < 0)
+                goto fail;
             is->audio_filter_src.fmt            = avctx->sample_fmt;
             if ((ret = AudioRenderer::configure_audio_filters(is, afilters, 0)) < 0) {
 				av_log(NULL, AV_LOG_ERROR, "Failed to configure audio filters: %d.\n", ret);
@@ -308,8 +312,11 @@ int StreamHandler::stream_component_open(VideoState *is, int stream_index) {
 			
             sink = is->out_audio_filter;
             sample_rate    = av_buffersink_get_sample_rate(sink);
-            nb_channels    = av_buffersink_get_channels(sink);
-            channel_layout = av_buffersink_get_channel_layout(sink);
+            //nb_channels    = av_buffersink_get_channels(sink);
+            //channel_layout = av_buffersink_get_channel_layout(sink);
+			ret = av_buffersink_get_ch_layout(sink, &ch_layout);
+            if (ret < 0)
+                goto fail;
         }
 #else
         sample_rate    = avctx->sample_rate;
@@ -318,7 +325,8 @@ int StreamHandler::stream_component_open(VideoState *is, int stream_index) {
 #endif
 
         /* prepare audio output */
-        if ((ret = AudioRenderer::audio_open(is, channel_layout, nb_channels, sample_rate, &is->audio_tgt)) < 0) {
+        //if ((ret = AudioRenderer::audio_open(is, channel_layout, nb_channels, sample_rate, &is->audio_tgt)) < 0) {
+		if ((ret = AudioRenderer::audio_open(is, &ch_layout, sample_rate, &is->audio_tgt)) < 0) {
 			av_log(NULL, AV_LOG_ERROR, "Failed to open audio output.\n");
             goto fail;
 		}
@@ -338,8 +346,11 @@ int StreamHandler::stream_component_open(VideoState *is, int stream_index) {
         is->audio_stream = stream_index;
         is->audio_st = ic->streams[stream_index];
 
-        DecoderC::decoder_init(&is->auddec, avctx, &is->audioq, is->continue_read_thread);
-        if ((is->ic->iformat->flags & (AVFMT_NOBINSEARCH | AVFMT_NOGENSEARCH | AVFMT_NO_BYTE_SEEK)) && !is->ic->iformat->read_seek) {
+        if ((ret = DecoderC::decoder_init(&is->auddec, avctx, &is->audioq, is->continue_read_thread)) < 0)
+            goto fail;
+		
+        //if ((is->ic->iformat->flags & (AVFMT_NOBINSEARCH | AVFMT_NOGENSEARCH | AVFMT_NO_BYTE_SEEK)) && !is->ic->iformat->read_seek) {
+		if (is->ic->iformat->flags & AVFMT_NOTIMESTAMPS) {
             is->auddec.start_pts = is->audio_st->start_time;
             is->auddec.start_pts_tb = is->audio_st->time_base;
         }
@@ -1166,7 +1177,7 @@ void StreamHandler::stream_cycle_channel(VideoState *is, int codec_type) {
             switch (codec_type) {
             case AVMEDIA_TYPE_AUDIO:
                 if (st->codecpar->sample_rate != 0 &&
-                    st->codecpar->channels != 0)
+                    st->codecpar->ch_layout.nb_channels != 0)
                     goto the_end;
                 break;
             case AVMEDIA_TYPE_VIDEO:
diff --git a/src/server/ffplay/types.h b/src/server/ffplay/types.h
index 3f144fe2..c445a7b7 100644
--- a/src/server/ffplay/types.h
+++ b/src/server/ffplay/types.h
@@ -116,8 +116,9 @@ typedef struct PacketQueue {
 
 typedef struct AudioParams {
 	int freq;
-	int channels;
-	int64_t channel_layout;
+    AVChannelLayout ch_layout;
+	//int channels;
+	//int64_t channel_layout;
 	enum AVSampleFormat fmt;
 	int frame_size;
 	int bytes_per_sec;
diff --git a/src/server/ffplay/video_renderer.cpp b/src/server/ffplay/video_renderer.cpp
index 5e41b216..fb3a009e 100644
--- a/src/server/ffplay/video_renderer.cpp
+++ b/src/server/ffplay/video_renderer.cpp
@@ -207,7 +207,7 @@ void VideoRenderer::video_refresh(void *opaque, double *remaining_time) {
 			//file_meta.position = master_clock;	// Copy to FleMetaInfo structure for the current file.
 			//FileMetaInfo::position = master_clock;	// Copy to FleMetaInfo structure for the current file.
 			//FileMetaInfo::setPosition(master_clock);
-			file_meta.setPosition(master_clock);
+			file_meta.setPosition(master_clock);/* 
             av_log(NULL, AV_LOG_INFO,
                    "%7.2f %s:%7.3f fd=%4d aq=%5dKB vq=%5dKB sq=%5dB f=%" PRId64"/%" PRId64"   \r",
                    master_clock,
@@ -218,7 +218,16 @@ void VideoRenderer::video_refresh(void *opaque, double *remaining_time) {
                    vqsize / 1024,
                    sqsize,
                    is->video_st ? is->viddec.avctx->pts_correction_num_faulty_dts : 0,
-                   is->video_st ? is->viddec.avctx->pts_correction_num_faulty_pts : 0);
+                   is->video_st ? is->viddec.avctx->pts_correction_num_faulty_pts : 0); */
+            av_log(NULL, AV_LOG_INFO,
+                   "%7.2f %s:%7.3f fd=%4d aq=%5dKB vq=%5dKB sq=%5dB  \r",
+                   master_clock,
+                   (is->audio_st && is->video_st) ? "A-V" : (is->video_st ? "M-V" : (is->audio_st ? "M-A" : "   ")),
+                   av_diff,
+                   is->frame_drops_early + is->frame_drops_late,
+                   aqsize / 1024,
+                   vqsize / 1024,
+                   sqsize);
             fflush(stdout);
             last_time = cur_time;
         }
---
From e5178e993b36c4843640801320eeeea1434bbfd0 Mon Sep 17 00:00:00 2001
From: Maya Posch <1096451+MayaPosch@users.noreply.github.com>
Date: Sat, 21 Sep 2024 15:44:45 +0200
Subject: [PATCH] Partial FFmpeg 7.0 updates to ffplay.

---
 src/server/ffplay/ffplay.cpp         |  1 +
 src/server/ffplay/stream_handler.cpp | 30 +++++++++++++++++++++-------
 2 files changed, 24 insertions(+), 7 deletions(-)

diff --git a/src/server/ffplay/ffplay.cpp b/src/server/ffplay/ffplay.cpp
index 681042cd..bdcd41f8 100644
--- a/src/server/ffplay/ffplay.cpp
+++ b/src/server/ffplay/ffplay.cpp
@@ -233,6 +233,7 @@ void Ffplay::run() {
 	//parse_options(NULL, argc, argv.data(), options, opt_input_file);
 	av_log_set_flags(AV_LOG_SKIP_REPEATED);
 	//av_log_set_level(AV_LOG_TRACE);
+	//av_log_set_level(AV_LOG_DEBUG);
 	av_log_set_level(AV_LOG_INFO);
 	
 	// Start main loop.
diff --git a/src/server/ffplay/stream_handler.cpp b/src/server/ffplay/stream_handler.cpp
index 03bc158c..f9429041 100644
--- a/src/server/ffplay/stream_handler.cpp
+++ b/src/server/ffplay/stream_handler.cpp
@@ -270,22 +270,37 @@ int StreamHandler::stream_component_open(VideoState *is, int stream_index) {
         avctx->flags2 |= AV_CODEC_FLAG2_FAST;
 
     opts = filter_codec_opts(codec_opts, avctx->codec_id, ic, ic->streams[stream_index], codec);
+    /* ret = filter_codec_opts(codec_opts, avctx->codec_id, ic,
+                            ic->streams[stream_index], codec, &opts);
+    if (ret < 0)
+        goto fail; */
+	
     if (!av_dict_get(opts, "threads", NULL, 0))
         av_dict_set(&opts, "threads", "auto", 0);
 	
     if (stream_lowres)
         av_dict_set_int(&opts, "lowres", stream_lowres, 0);
 	
-    if (avctx->codec_type == AVMEDIA_TYPE_VIDEO || avctx->codec_type == AVMEDIA_TYPE_AUDIO)
-        av_dict_set(&opts, "refcounted_frames", "1", 0);
+    /* if (avctx->codec_type == AVMEDIA_TYPE_VIDEO || avctx->codec_type == AVMEDIA_TYPE_AUDIO)
+        av_dict_set(&opts, "refcounted_frames", "1", 0); */
+	
+	av_dict_set(&opts, "flags", "+copy_opaque", AV_DICT_MULTIKEY);
+
+    /* if (avctx->codec_type == AVMEDIA_TYPE_VIDEO) {
+        ret = create_hwaccel(&avctx->hw_device_ctx);
+        if (ret < 0)
+            goto fail;
+    } */
 	
     if ((ret = avcodec_open2(avctx, codec, &opts)) < 0) {
 		av_log(NULL, AV_LOG_ERROR, "avcodec_open2() failed.\n");
         goto fail;
     }
 	
-    if ((t = av_dict_get(opts, "", NULL, AV_DICT_IGNORE_SUFFIX)) && t == 0) {
-        av_log(NULL, AV_LOG_ERROR, "Option not found.\n");
+    //if ((t = av_dict_get(opts, "", NULL, AV_DICT_IGNORE_SUFFIX)) && t == 0) {
+	if ((t = av_dict_get(opts, "", NULL, AV_DICT_IGNORE_SUFFIX))) {
+        //av_log(NULL, AV_LOG_ERROR, "Option not found.\n");
+		av_log(NULL, AV_LOG_ERROR, "Option %s not found.\n", t->key);
         ret =  AVERROR_OPTION_NOT_FOUND;
         goto fail;
     }
@@ -294,7 +309,7 @@ int StreamHandler::stream_component_open(VideoState *is, int stream_index) {
     ic->streams[stream_index]->discard = AVDISCARD_DEFAULT;
     switch (avctx->codec_type) {
     case AVMEDIA_TYPE_AUDIO:
-#if CONFIG_AVFILTER
+//#if CONFIG_AVFILTER
         {
             AVFilterContext *sink;
 
@@ -318,11 +333,11 @@ int StreamHandler::stream_component_open(VideoState *is, int stream_index) {
             if (ret < 0)
                 goto fail;
         }
-#else
+/* #else
         sample_rate    = avctx->sample_rate;
         nb_channels    = avctx->channels;
         channel_layout = avctx->channel_layout;
-#endif
+#endif */
 
         /* prepare audio output */
         //if ((ret = AudioRenderer::audio_open(is, channel_layout, nb_channels, sample_rate, &is->audio_tgt)) < 0) {
@@ -383,6 +398,7 @@ int StreamHandler::stream_component_open(VideoState *is, int stream_index) {
 fail:
     avcodec_free_context(&avctx);
 out:
+    av_channel_layout_uninit(&ch_layout);
     av_dict_free(&opts);
 
     return ret;
